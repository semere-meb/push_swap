*This project has been created as part of the 42 curriculum by semebrah*

# Description

`push_swap` is a small program that sorts integer stacks using a restricted set
of operations. The goal is to produce a sequence of operations that sorts the
numbers with the minimum possible moves. This repository contains an
implementation of the `push_swap` project along with supporting utilities and
an optional bonus checker.

# Instructions

- **Build:** run `make` at the repository root. This will compile `push_swap`.

- **Usage:**
    - To run the program and get a sequence of operations that sorts the input:

``` bash
		./push_swap 3 2 1 0
```

- The program expects a list of integers as arguments. It prints the list of
		operations to standard output (one operation per line).

- **Checker (bonus):** build the checker program using `make bonus` rule. You can pipe the operations produced by `push_swap` into it and passing the same arguments as the push_swap program. Example:

``` bash
		./push_swap 3 2 1 | ./checker 3 2 1
```
- **Cleaning:** run `make clean` to remove object files and `make fclean` to remove all objects and target binaries.

- **Notes:** the repository includes a `libft/` folder with helper functions
	used by the project.
# Data structures & Algorithm

## Data Structures ##

This implementation represents each element as a `t_node` and each stack as a
`t_stack` (see `push_swap.h`). Key details:

- `t_node` fields:
	- `prev`, `next`: pointers for a circular doubly-linked list that stores the
		stack elements in order.
	- `target`: a pointer used to mark the node in the other stack that this
		node should be moved next to (used by the Turk algorithm to compute where
		a node from stack B should land in stack A).
	- `val`: the integer value held by the node.
	- `index`: the normalized rank/index of the value (useful for chunking and
		comparing positions regardless of original values).
	- `c_cost`, `n_cost`, `t_cost`: cost metrics used to compute the number of
		operations required to move this node into place (combined cost and per-
		stack rotation costs).

- `t_stack` fields:
	- `head`: pointer to the current top node of the circular list.
	- `length`: tracked length (some helpers compute size on demand as well).
	- `max`, `min`: convenience pointers for extreme values.
	- `cheapest`: pointer to the node currently identified as the lowest-cost
		candidate to move.

The stacks are implemented as circular doubly-linked lists (see
`stack.c`/`stack2.c`): `stack_push`, `stack_pop`, `stack_swap`, `stack_rotate`,
and `stack_reverse` manipulate the `head` pointer and node links to perform the
standard push_swap operations in O(1) time for pointer updates. Iteration and
index lookups are provided by `stack_iter`, `node_val`, and `node_index`.

## Turk algorithm (Overview) ##

The Turk algorithm is a practical approach for `push_swap` that minimizes the
number of operations by computing targeted, cheap moves rather than blindly
shuffling elements. The goal is that we move elements from stack A to stack B in such a way that makes stack B sorted in decending order so that when we put the elements back, stack A would be sorted in ascending order:

1. Start off by moving 2 elements from A to B so we have some numbers that we can target and compare
2. For each element in A, assign a target in B, that would make B sorted -- an element that is the next bigger number less than the one at A.
3. For each element calculate how many operations it would take to put it on top of its target
4. Move the cheapest element from A to B.
5. Repeat from 2 untill there are 3 elements remaining in A.
5. Sort the last 3 remainig elements in A.
6. Set a target for B's top element in B (an element in B that is next bigger or the minimum)
7. Move the target to top and push B's top to A.
8. Reapeat from 6 untill B is empty.
9. Move the minimum to the top

# Resources

- A. Yigit Ogun's medium article on The Turk sorting algorithm - https://medium.com/@ayogun/push-swap-c1f5d2d41e97

**AI usage:** AI assistance was used to draft and format this `README.md` file
only (project text, usage examples, and resources). No source-code logic or
algorithm implementation was generated by AI.
 
